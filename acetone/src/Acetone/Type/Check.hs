{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeApplications #-}

-- |
-- Checking a compilation unit is a two-step process:
--
--  1. Extract the signatures.
--  2. Type check all value definitions.
module Acetone.Type.Check
  ( -- * High-level
    checkAll

    -- * Checking
  , Check
  , runCheck
  , withLocation

    -- ** Interfaces
  , extractValueSigs

    -- ** Units
  , checkUnit

    -- ** Type expressions
  , translateTypeExp

    -- ** Term expressions
  , checkTermExp
  , inferTermExp

    -- * Inference
  , Infer
  , runInfer

    -- ** Solving
  , solve
  , unify
  , unify'

    -- ** Environment
  , Œì (..)

    -- ** State
  , Œ£ (..)
  , freshUnknown
  , freshSkolem
  , instantiate
  , skolemize
  , constrain
  , resolve
  , purge

    -- * Errors
  , Œ®
  , Œ®' (..)
  , throwError

    -- * Optics
  , _Œ≥Values
  , _œÉNext
  , _œÉConstraints
  , _œÉResolveds
  ) where

import Acetone.Ast

import Acetone.Type (Skolem (..), Type (..), Type', Unknown (..), hideUniverse, inUniverse)
import Acetone.Type.Constraint (Constraint (..))
import Control.Lens (Lens', (&), (^.), (^?), (?~), (%=), (?=), (<<+=), _2, at, ix, lens, use)
import Control.Monad.Error.Class (MonadError)
import Control.Monad.Reader.Class (MonadReader)
import Control.Monad.Trans.Reader (ReaderT, runReaderT)
import Control.Monad.Trans.State (StateT (..), evalStateT)
import Data.Bifunctor (first, second)
import Data.Foldable (for_, traverse_)
import Data.Function (fix)
import Data.List (sortBy)
import Data.Map (Map)
import Data.Maybe (fromMaybe)
import Data.Ord (comparing)
import Data.Set (Set)
import Data.Traversable (for)
import Data.Word (Word64)
import GHC.TypeLits (KnownNat)

import qualified Control.Monad.Error.Class as Error
import qualified Control.Monad.Reader.Class as Reader
import qualified Data.Map as Map
import qualified Data.Set as Set

--------------------------------------------------------------------------------
-- High-level

checkAll :: Unit -> Either Œ® ()
checkAll ds = runCheck $
  let xs = extractValueSigs ds in
  checkUnit (fmap (^. _2) xs) ds

--------------------------------------------------------------------------------
-- Check

type Check =
  ReaderT Location (Either Œ®)

runCheck :: Check a -> Either Œ® a
runCheck a = runReaderT a (Location "" 0 0)

withLocation :: (MonadReader Location f) => Location -> f a -> f a
withLocation = Reader.local . const

--------------------------------------------------------------------------------
-- Extract

extractValueSigs :: Unit -> Map Name (Linkage, Type 0)
extractValueSigs =
  -- TODO: Handle duplicate definitions.
  foldMap $ fix $ \f -> \case
    LocationDef _ d   -> (f d)
    ValueSigDef n l œÑ -> Map.singleton n (l, translateTypeExp Set.empty œÑ)
    ValueDef{}        -> Map.empty

--------------------------------------------------------------------------------
-- Units

-- |
-- Given the interface, type check a unit.
checkUnit :: Map Name (Type 0) -> Unit -> Check ()
checkUnit xs ds =
  for_ ds $ fix $ \f -> \case
    LocationDef l d -> withLocation l (f d)
    ValueSigDef{}   -> pure ()
    ValueDef x e    ->
      case xs ^? ix x of
        Nothing -> throwError $ UnknownValue x
        Just œÑ  -> checkTermExp xs œÑ e

--------------------------------------------------------------------------------
-- Type expressions

-- |
-- Given a type expression, return the corresponding type.
translateTypeExp :: Set Name -> TypeExp ùî≤ -> Type ùî≤

translateTypeExp Œ≥ (LocationTypeExp _ œÑ) =
  translateTypeExp Œ≥ œÑ

translateTypeExp Œ≥ (VariableTypeExp x)
  | x `Set.member` Œ≥ = LocalType x
  | otherwise        = GlobalType x

translateTypeExp Œ≥ (ApplyTypeExp œÑ‚ÇÅ œÑ‚ÇÇ) =
  ApplyType (translateTypeExp Œ≥ œÑ‚ÇÅ)
            (translateTypeExp Œ≥ œÑ‚ÇÇ)

translateTypeExp Œ≥ (ForAllTypeExp x œÑ) =
  ForAllType x (translateTypeExp (Set.insert x Œ≥) œÑ)

translateTypeExp Œ≥ (RowConsTypeExp x œÑ‚ÇÅ œÑ‚ÇÇ) =
  RowConsType x (translateTypeExp Œ≥ œÑ‚ÇÅ)
              (translateTypeExp Œ≥ œÑ‚ÇÇ)

translateTypeExp _ RowNilTypeExp =
  RowNilType

--------------------------------------------------------------------------------
-- Term expressions

-- |
-- Check that a term has the given expected type. The given type will first be
-- Skolemized.
checkTermExp :: Map Name (Type 0) -> Type 0 -> TermExp -> Check ()
checkTermExp xs œÑ e =
  runInfer $ do

    -- Check that term has expected type.
    let Œ≥ = Œì { Œ≥Values = xs }
    œÑ' <- skolemize œÑ
    œÑe <- inferTermExp Œ≥ e
    constrain $ œÑ' :~: œÑe

    -- Solve constraints.
    use _œÉConstraints >>= traverse_ solve

inferTermExp :: Œì -> TermExp -> Infer (Type 0)

inferTermExp Œ≥ (LocationTermExp l e) =
  withLocation l (inferTermExp Œ≥ e)

inferTermExp Œ≥ (VariableTermExp x) =
  case Œ≥ ^? _Œ≥Values . ix x of
    Nothing -> throwError (UnknownValue x)
    Just œÑ -> instantiate œÑ

inferTermExp Œ≥ (LambdaTermExp x e) = do
  œÑx <- UnknownType <$> freshUnknown

  let Œ≥e = Œ≥ & _Œ≥Values . at x ?~ œÑx
  œÑe <- inferTermExp Œ≥e e

  -- TODO: Replace (Name "function") type by intrinsic.
  let œÑŒª = ApplyType (ApplyType (GlobalType (Name "function")) œÑx) œÑe

  pure œÑŒª

inferTermExp Œ≥ (ApplyTermExp e‚ÇÅ e‚ÇÇ) = do
  œÑe‚ÇÅ <- inferTermExp Œ≥ e‚ÇÅ
  œÑe‚ÇÇ <- inferTermExp Œ≥ e‚ÇÇ

  œÑr <- UnknownType <$> freshUnknown
  -- TODO: Replace (Name "function") type by intrinsic.
  constrain $ œÑe‚ÇÅ :~: ApplyType (ApplyType (GlobalType (Name "function")) œÑe‚ÇÇ) œÑr

  pure œÑr

inferTermExp Œ≥ (DeferTermExp e) = do
  œÑe <- inferTermExp Œ≥ e
  -- TODO: Replace (Name "lazy") type by intrinsic.
  pure $ ApplyType (GlobalType (Name "lazy"))
                  œÑe

inferTermExp Œ≥ (ForceTermExp e) = do
  œÑe <- inferTermExp Œ≥ e
  œÑr <- UnknownType <$> freshUnknown
  -- TODO: Replace (Name "lazy") type by intrinsic.
  constrain $ œÑe :~: ApplyType (GlobalType (Name "lazy")) œÑr
  pure œÑr

inferTermExp Œ≥ (RecordTermExp es) = do
  -- TODO: Check for duplicate elements.
  œÑes <- traverse (traverse (inferTermExp Œ≥)) es
  -- TODO: Replace (Name "record") type by intrinsic.
  pure $ ApplyType (GlobalType (Name "record"))
                   (foldr (uncurry RowConsType) RowNilType œÑes)

inferTermExp Œ≥ (RecordFieldTermExp e x) = do
  œÑe <- inferTermExp Œ≥ e

  œÑx <- UnknownType <$> freshUnknown
  œÑœÅ <- UnknownType <$> freshUnknown
  -- TODO: Replace (Name "record") type by intrinsic.
  constrain $ œÑe :~: ApplyType (GlobalType (Name "record"))
                               (RowConsType x œÑx œÑœÅ)

  pure œÑx

inferTermExp Œ≥ (VariantTermExp x e) = do
  œÑe <- inferTermExp Œ≥ e
  œÑœÅ <- UnknownType <$> freshUnknown
  -- TODO: Replace (Name "variant") type by intrinsic.
  pure $ ApplyType (GlobalType (Name "variant"))
                   (RowConsType x œÑe œÑœÅ)

inferTermExp Œ≥ (EvaluateTermExp e‚ÇÅ es) = do
  œÑe‚ÇÅ <- inferTermExp Œ≥ e‚ÇÅ

  œÑr <- UnknownType <$> freshUnknown
  œÑes <- for es $ \(x, x', e‚ÇÇ) -> do
    œÑx' <- UnknownType <$> freshUnknown
    let Œ≥e‚ÇÇ = Œ≥ & _Œ≥Values . at x' ?~ œÑx'
    œÑe‚ÇÇ <- inferTermExp Œ≥e‚ÇÇ e‚ÇÇ
    constrain $ œÑe‚ÇÇ :~: œÑr
    pure (x, œÑx')

  -- TODO: Replace (Name "variant") type by intrinsic.
  constrain $ œÑe‚ÇÅ :~: ApplyType (GlobalType (Name "variant"))
                                (foldr (uncurry RowConsType) RowNilType œÑes)

  pure œÑr

--------------------------------------------------------------------------------
-- Inference

type Infer =
  StateT Œ£ Check

runInfer :: Infer a -> Check a
runInfer a =
  let œÉ = Œ£ { œÉNext = 0, œÉConstraints = [], œÉResolveds = Map.empty } in
  evalStateT a œÉ

--------------------------------------------------------------------------------
-- Solving

solve :: Constraint -> Infer ()
solve (œÑ‚ÇÅ :~: œÑ‚ÇÇ) = unify œÑ‚ÇÅ œÑ‚ÇÇ

unify :: KnownNat ùî≤ => Type ùî≤ -> Type ùî≤ -> Infer ()
unify = \œÑ‚ÇÅ œÑ‚ÇÇ -> do
  œÑ‚ÇÅ' <- purge œÑ‚ÇÅ
  œÑ‚ÇÇ' <- purge œÑ‚ÇÇ
  unify' œÑ‚ÇÅ' œÑ‚ÇÇ'

unify' :: KnownNat ùî≤ => Type ùî≤ -> Type ùî≤ -> Infer ()

unify' (UnknownType œÖ‚ÇÅ) (UnknownType œÖ‚ÇÇ) | œÖ‚ÇÅ == œÖ‚ÇÇ = pure ()
unify' (UnknownType œÖ) œÑ = resolve œÖ œÑ
unify' œÑ (UnknownType œÖ) = resolve œÖ œÑ

unify' (SkolemType s‚ÇÅ) (SkolemType s‚ÇÇ) | s‚ÇÅ == s‚ÇÇ = pure ()
unify' œÑ‚ÇÅ@SkolemType{} œÑ‚ÇÇ = cannotUnify œÑ‚ÇÅ œÑ‚ÇÇ
unify' œÑ‚ÇÇ œÑ‚ÇÅ@SkolemType{} = cannotUnify œÑ‚ÇÅ œÑ‚ÇÇ

unify' (GlobalType x‚ÇÅ) (GlobalType x‚ÇÇ) | x‚ÇÅ == x‚ÇÇ = pure ()
unify' œÑ‚ÇÅ@GlobalType{} œÑ‚ÇÇ = cannotUnify œÑ‚ÇÅ œÑ‚ÇÇ
unify' œÑ‚ÇÇ œÑ‚ÇÅ@GlobalType{} = cannotUnify œÑ‚ÇÅ œÑ‚ÇÇ

unify' (LocalType x‚ÇÅ) (LocalType x‚ÇÇ) | x‚ÇÅ == x‚ÇÇ = pure ()
unify' œÑ‚ÇÅ@LocalType{} œÑ‚ÇÇ = cannotUnify œÑ‚ÇÅ œÑ‚ÇÇ
unify' œÑ‚ÇÇ œÑ‚ÇÅ@LocalType{} = cannotUnify œÑ‚ÇÅ œÑ‚ÇÇ

unify' (ApplyType œÑ‚ÇÅ œÑ‚ÇÇ) (ApplyType œÑ‚ÇÉ œÑ‚ÇÑ) = do { unify œÑ‚ÇÅ œÑ‚ÇÉ; unify œÑ‚ÇÇ œÑ‚ÇÑ }

unify' ForAllType{} _ = throwError HigherRankType
unify' _ ForAllType{} = throwError HigherRankType

unify' œÑ‚ÇÅ@RowConsType{} œÑ‚ÇÇ = unifyRows œÑ‚ÇÅ œÑ‚ÇÇ
unify' œÑ‚ÇÅ œÑ‚ÇÇ@RowConsType{} = unifyRows œÑ‚ÇÅ œÑ‚ÇÇ

unify' œÑ‚ÇÅ@RowNilType{} œÑ‚ÇÇ = unifyRows œÑ‚ÇÅ œÑ‚ÇÇ
unify' œÑ‚ÇÅ œÑ‚ÇÇ@RowNilType{} = unifyRows œÑ‚ÇÅ œÑ‚ÇÇ

cannotUnify :: KnownNat ùî≤ => Type ùî≤ -> Type ùî≤ -> Infer a
cannotUnify œÑ‚ÇÅ œÑ‚ÇÇ = do
  œÑ‚ÇÅ' <- purge' œÑ‚ÇÅ
  œÑ‚ÇÇ' <- purge' œÑ‚ÇÇ
  throwError $ CannotUnify œÑ‚ÇÅ' œÑ‚ÇÇ'

--------------------------------------------------------------------------------
-- Row type unification

-- DISCLAIMER: This code was copied from the PureScript compiler and adapted to
-- DISCLAIMER: work with the Acetone AST and Type types. Credit goes to the
-- DISCLAIMER: original authors. Naming and formatting are largely preserved
-- DISCLAIMER: and hence inconsistent with the rest of this code base.

data RowListItem ùî≤ = RowListItem
  { rowListLabel :: Name
  , _rowListType :: Type ùî≤ }

unifyRows :: forall ùî≤. KnownNat ùî≤ => Type ùî≤ -> Type ùî≤ -> Infer ()
unifyRows r1 r2 = sequence_ matches *> uncurry unifyTails rest where
  (matches, rest) = alignRowsWith unify r1 r2

  unifyTails :: ([RowListItem ùî≤], Type ùî≤) -> ([RowListItem ùî≤], Type ùî≤) -> Infer ()

  unifyTails ([], UnknownType u) (sd, r) = resolve u (rowFromList (sd, r))
  unifyTails (sd, r) ([], UnknownType u) = resolve u (rowFromList (sd, r))
  unifyTails (sd1, UnknownType u1) (sd2, UnknownType u2) = do
    -- TODO: Occurs check.
    rest' <- UnknownType <$> freshUnknown
    resolve u1 (rowFromList (sd2, rest'))
    resolve u2 (rowFromList (sd1, rest'))

  unifyTails ([], SkolemType s1) ([], SkolemType s2) | s1 == s2 = return ()
  unifyTails (_, SkolemType{}) _ = cannotUnify r1 r2
  unifyTails _ (_, SkolemType{}) = cannotUnify r1 r2

  unifyTails ([], GlobalType v1) ([], GlobalType v2) | v1 == v2 = return ()
  unifyTails (_, GlobalType{}) _ = cannotUnify r1 r2
  unifyTails _ (_, GlobalType{}) = cannotUnify r1 r2

  unifyTails ([], LocalType v1) ([], LocalType v2) | v1 == v2 = return ()
  unifyTails (_, LocalType{}) _ = cannotUnify r1 r2
  unifyTails _ (_, LocalType{}) = cannotUnify r1 r2

  unifyTails (_, ApplyType{}) _ = cannotUnify r1 r2
  unifyTails _ (_, ApplyType{}) = cannotUnify r1 r2

  unifyTails (_, ForAllType{}) _ = throwError HigherRankType
  unifyTails _ (_, ForAllType{}) = throwError HigherRankType

  unifyTails (_, RowConsType{}) _ = cannotUnify r1 r2 -- Should never happen?
  unifyTails _ (_, RowConsType{}) = cannotUnify r1 r2 -- Should never happen?

  unifyTails ([], RowNilType) ([], RowNilType) = return ()
  unifyTails (_, RowNilType) _ = return ()
  unifyTails _ (_, RowNilType) = return ()

alignRowsWith
  :: (Type ùî≤ -> Type ùî≤ -> r)
  -> Type ùî≤
  -> Type ùî≤
  -> ([r], (([RowListItem ùî≤], Type ùî≤), ([RowListItem ùî≤], Type ùî≤)))
alignRowsWith f ty1 ty2 = go s1 s2 where
  (s1, tail1) = rowToSortedList ty1
  (s2, tail2) = rowToSortedList ty2

  go [] r = ([], (([], tail1), (r, tail2)))
  go r [] = ([], ((r, tail1), ([], tail2)))
  go lhs@(RowListItem l1 t1 : r1) rhs@(RowListItem l2 t2 : r2)
    | l1 < l2 = (second . first . first) (RowListItem l1 t1 :) (go r1 rhs)
    | l2 < l1 = (second . second . first) (RowListItem l2 t2 :) (go lhs r2)
    | otherwise = first (f t1 t2 :) (go r1 r2)

rowToList :: Type ùî≤ -> ([RowListItem ùî≤], Type ùî≤)
rowToList = go where
  go (RowConsType name ty row) =
    first (RowListItem name ty :) (rowToList row)
  go r = ([], r)

rowToSortedList :: Type ùî≤ -> ([RowListItem ùî≤], Type ùî≤)
rowToSortedList = first (sortBy (comparing rowListLabel)) . rowToList

rowFromList :: ([RowListItem ùî≤], Type ùî≤) -> Type ùî≤
rowFromList (xs, r) = foldr (\(RowListItem name ty) -> RowConsType name ty) r xs

--------------------------------------------------------------------------------
-- Environment

newtype Œì :: * where
  Œì
    :: { Œ≥Values :: Map Name (Type 0) }
    -> Œì

--------------------------------------------------------------------------------
-- State

data Œ£ :: * where
  Œ£
    :: { œÉNext        :: Word64
       , œÉConstraints :: [Constraint]
       , œÉResolveds   :: Map Unknown Type' }
    -> Œ£

freshUnknown :: Infer Unknown
freshUnknown = fmap Unknown $ _œÉNext <<+= 1

freshSkolem :: Infer Skolem
freshSkolem = fmap Skolem $ _œÉNext <<+= 1

instantiate :: Type ùî≤ -> Infer (Type ùî≤)
instantiate = instantemize (UnknownType <$> freshUnknown)

skolemize :: Type ùî≤ -> Infer (Type ùî≤)
skolemize = instantemize (SkolemType <$> freshSkolem)

-- |
-- Shared implementation of 'instantiate' and 'skolemize'.
instantemize :: Infer (Type ùî≤) -> Type ùî≤ -> Infer (Type ùî≤)
instantemize œÜ = go0 Map.empty
  where
  go0 Œ≥ (ForAllType x œÑ) = do { x' <- œÜ; go0 (Map.insert x x' Œ≥) œÑ }
  go0 Œ≥ œÑ = go1 Œ≥ œÑ

  go1 _ œÑ@UnknownType{}       = pure œÑ
  go1 _ œÑ@SkolemType{}        = pure œÑ
  go1 _ œÑ@GlobalType{}        = pure œÑ
  go1 Œ≥ œÑ@(LocalType x)       = pure $ fromMaybe œÑ (Œ≥ ^? ix x)
  go1 Œ≥ (ApplyType œÑ‚ÇÅ œÑ‚ÇÇ)     = ApplyType <$> go1 Œ≥ œÑ‚ÇÅ <*> go1 Œ≥ œÑ‚ÇÇ
  go1 _ ForAllType{}          = throwError HigherRankType
  go1 Œ≥ (RowConsType x œÑ‚ÇÅ œÑ‚ÇÇ) = RowConsType x <$> go1 Œ≥ œÑ‚ÇÅ <*> go1 Œ≥ œÑ‚ÇÇ
  go1 _ œÑ@RowNilType          = pure œÑ

constrain :: Constraint -> Infer ()
constrain = (_œÉConstraints %=) . (:)

-- |
-- Resolve an unknown.
resolve :: KnownNat ùî≤ => Unknown -> Type ùî≤ -> Infer ()
resolve œÖ œÑ = _œÉResolveds . at œÖ ?= hideUniverse œÑ

-- |
-- Follow resolveds recursively until an unresolved unknown or a known type is
-- found. Will fail if the universe of the result is different from the
-- universe of the input, but this shouldn't happen.
purge :: forall ùî≤. KnownNat ùî≤ => Type ùî≤ -> Infer (Type ùî≤)
purge œÑ@(UnknownType œÖ) =
  use (_œÉResolveds . at œÖ) >>= do
    maybe (pure œÑ) $
      maybe (throwError PurgeInvalidUniverse) purge .
        inUniverse @ùî≤
purge œÑ = pure œÑ

-- |
-- Like 'purge', but purge the entire tree instead of just the root.
purge' :: KnownNat ùî≤ => Type ùî≤ -> Infer (Type ùî≤)
purge' œÑ =
  purge œÑ >>= \case
    œÑ'@UnknownType{}      -> pure œÑ'
    œÑ'@SkolemType{}       -> pure œÑ'
    œÑ'@GlobalType{}       -> pure œÑ'
    œÑ'@LocalType{}        -> pure œÑ'
    ApplyType œÑ'‚ÇÅ œÑ'‚ÇÇ     -> ApplyType <$> purge' œÑ'‚ÇÅ <*> purge' œÑ'‚ÇÇ
    ForAllType{}          -> throwError HigherRankType
    RowConsType x œÑ'‚ÇÅ œÑ'‚ÇÇ -> RowConsType x <$> purge' œÑ'‚ÇÅ <*> purge' œÑ'‚ÇÇ
    œÑ'@RowNilType         -> pure œÑ'

--------------------------------------------------------------------------------
-- Errors

type Œ® = (Location, Œ®')

data Œ®' :: * where
  UnknownValue :: Name -> Œ®'
  CannotUnify :: Type ùî≤ -> Type ùî≤ -> Œ®'
  PurgeInvalidUniverse :: Œ®'
  HigherRankType :: Œ®'
deriving stock instance Show Œ®'

throwError :: (MonadReader Location f, MonadError Œ® f) => Œ®' -> f a
throwError œà = do
  l <- Reader.ask
  Error.throwError (l, œà)

--------------------------------------------------------------------------------
-- Optics

_Œ≥Values :: Lens' Œì (Map Name (Type 0))
_Œ≥Values = lens Œ≥Values (\s a -> s { Œ≥Values = a })

_œÉNext :: Lens' Œ£ Word64
_œÉNext = lens œÉNext (\s a -> s { œÉNext = a })

_œÉConstraints :: Lens' Œ£ [Constraint]
_œÉConstraints = lens œÉConstraints (\s a -> s { œÉConstraints = a })

_œÉResolveds :: Lens' Œ£ (Map Unknown Type')
_œÉResolveds = lens œÉResolveds (\s a -> s { œÉResolveds = a })
